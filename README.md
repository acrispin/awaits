# awaits - делаем работу с асинхронными / многопоточными приложениями проще

Данная библиотека решает 3 проблемы:

- Асинхронное программирование с использованием синтаксиса async/await теряет смысл, если в коде часто встречаются куски с "тяжелыми" вычислениями, которые блокируют event-loop. Зато теперь вы можете навесить на такую "тяжелую" функцию декоратор ```@awaitable``` и она станет корутиной, которая будет исполняться в отдельном потоке, не блокируя event-loop. Во всем остальном это будет совершенно обычная корутина.
- Многопоточное программирование многословно. Чтобы заставить ваш код исполняться в многопоточном режиме, вам нужно создавать объекты потоков, передавать туда нужные функции и запускать потоки. Теперь же вам достаточно навесить на обычную функцию декоратор и она автоматически будет исполняться в многопоточном режиме.
- Частое создание потоков в программе требует постоянно отслеживать создание потоков и управление ими. Здесь же минимальным уровнем абстракции для вас становится группа потоков (pool of threads), а не какой-то отдельный поток. Ими становится удобно управлять в рамках т. н. "комнат" (rooms) с такими группами, где каждой группе присваивается имя.

Прочитайте документацию ниже, чтобы увидеть, как все это работает.



## Оглавление

- [**Быстрый старт**](#быстрый-старт)
- [**Как это все работает?**](#как-это-все-работает)
- [**Как работает группа потоков?**](#как-работает-группа-потоков)
- [**Что такое "комната"?**](#что-такое-комната)
- [**Декоратор ```@awaitable```**](#декоратор-awaitable)
- [**Декоратор ```@shoot```**](#декоратор-shoot)
- [**Настройки по умолчанию**](#настройки-по-умолчанию)

## Быстрый старт

Установите awaitable через [pip](https://pypi.org/project/awaitable/):

```
pip install awaits
```

Теперь просто импортируйте декоратор ```@awaitable``` и примените его к вашей функции. Никаких настроек, ничего лишнего - все уже работает:

```python
import asyncio
from awaits.awaitable import awaitable


@awaitable
def sum(a, b):
  # Какой-то сложный датасаенз. Что-то, что вычисляется долго и мешает вашему event-loop'у жить.
  return a + b

# Теперь sum - это корутина! Пока она выполняется в отдельном потоке, управление передается в event-loop.
asyncio.run(sum(2, 2))
```

Готово! Мы сделали из обычной функции неблокирующую event-loop корутину, к которой теперь применим синтаксис await.
